/* 
 * Parser for models generated by DLV
 *
 * Giselle Reis 
 * 2013
 *
 * NOTE: not checking whether the symbols exist or not
 */

%{
  
(* Header (OCaml code) *)

open Types
open TypeChecker

let parse_error s = 
  print_endline "Error parsing model from DLV.";
  print_endline s;
  flush stdout

let make_APP lst = 
  match lst with
  | [t] -> t
  | t1 :: body -> APP(t1, body)
  | [] -> failwith "Cannot make application with empty list."

%}

/* OCamlyacc declarations (names of terminal and non-terminal symbols, operator
   precedence, etc.)
*/

/* Terminal symbols */
%token <int> INDEX
%token <string> NAME STRING VAR ABS NEW
%token IN INUNQ INFINAL EMP UNION SETMINUS CONTAINED MAXIDX NOTMAXIDX
%token INVLOLLI LOLLI TIMES PLUS PIPE WITH TOP BOT ONE ZERO BANG QST NOT FORALL EXISTS
%token COMMA LBRACKET RBRACKET LCURLY RCURLY LPAREN RPAREN UNDERSCORE DOT NEWLINE QUOTE
%right FORALL EXISTS
%left TIMES
%left PLUS
%left PIPE
%left WITH 
%left LOLLI
%right NOT NEW
%right QST BANG

/* Start symbol */
%start model
%type <Constraints.constraintpred list> model

/* Using this a start symbol will only parse and not return a model */
%start input
%type <unit> input

%% 

/* Grammar rules */

input:
  /* empty */  { }
  | NEWLINE { } 
  | model NEWLINE {  }
;

model: 
  /* empty */                   { [] }
  | constraintPred              { $1 }
  | constraintPred COMMA model  { $1 @ $3 }
  | LCURLY model RCURLY         { $2 }
;

constraintPred:
  | IN LPAREN QUOTE formula QUOTE COMMA contextVar COMMA INDEX RPAREN { [] }
  | INUNQ LPAREN QUOTE formula QUOTE COMMA INDEX COMMA contextVar RPAREN { [] }
  | CONTAINED LPAREN QUOTE formula QUOTE COMMA contextVar RPAREN { [] }
  | MAXIDX LPAREN QUOTE formula QUOTE COMMA INDEX COMMA contextVar RPAREN { [] }
  | NOTMAXIDX LPAREN QUOTE formula QUOTE COMMA INDEX COMMA contextVar RPAREN { [] }
  | INFINAL LPAREN QUOTE formula QUOTE COMMA contextVar COMMA INDEX RPAREN {
    let f = deBruijn true $4 in
    [Constraints.IN(f, $7, $9)]
  }
  | EMP LPAREN contextVar RPAREN { 
    [Constraints.EMP($3)]
  }
  | SETMINUS LPAREN contextVar COMMA QUOTE formula QUOTE COMMA contextVar RPAREN { 
    let f = deBruijn true $6 in
    [Constraints.SETMINUS($3, f, $9)]
  }
  | UNION LPAREN contextVar COMMA contextVar COMMA contextVar RPAREN { 
    [Constraints.UNION($3, $5, $7)]
  }
  ;

contextVar: 
  | NAME UNDERSCORE INDEX { ($1, $3) }
;

formula:
  /* For horn-clause-like definitions (we make no restrictions) */
  | formula INVLOLLI formula    { LOLLI (CONST("gamma"), $1, $3) }
  /* A -o B : A -o B*/
  | formula LOLLI formula       { LOLLI (CONST("gamma"), $3, $1) }
  /* A ⊗ B : A * B */
  | formula TIMES formula       { TENSOR ($1, $3)}
  /* A ⊕ B : A + B */
  | formula PLUS formula        { ADDOR ($1, $3)}
  /* A ⅋ B : A | B */
  | formula PIPE formula        { PARR ($1, $3)}
  /* A & B : A & B */
  | formula WITH formula        { WITH ($1, $3)}
  /* !^l F : ![l] F */
  | BANG LBRACKET term RBRACKET formula  {BANG ($3,$5)}
  /* ?^l F : ?[l] F */
  | QST LBRACKET term RBRACKET formula   {QST ($3,$5)}
  /* !^infty F : ! F */
  | BANG formula             { BANG (CONST("infty"),$2) }
  /* ?^infty F : ? F */
  | QST formula              { QST (CONST("infty"),$2) }
  /* F^{perp} : not F (the formula is already stored in NNF) */
  | NOT formula              { Term.nnf (NOT($2)) }
  /* ∀ x. F : all x F */
  | FORALL VAR formula       { FORALL ($2, 0, $3) } 
  /* ∃ x. F : exs x F */
  | EXISTS VAR formula       { EXISTS ($2, 0, $3) } 
  /* (F) */
  | LPAREN formula RPAREN    { $2 }
  /* propositional variable */
  | pred    { $1 }
  /* T, 1, bot, 0 */
  | TOP  { TOP }
  | BOT  { BOT }
  | ONE  { ONE }
  | ZERO { ZERO }
;

pred:
  | NAME         { PRED ($1, CONST($1), NEG) } 
  | NAME terms   { PRED ($1, APP(CONST($1), $2), NEG ) }
  | VAR          { VAR {str = $1; id = 0; tag = LOG; ts = 0; lts = 0} }
  | VAR terms { 
    let var_head =  VAR {str = $1; id = 0; tag = LOG; ts = 0; lts = 0} in
    APP(var_head, $2)
  }
;

terms:
  | term                        { [$1] }
  | term terms                  { $1 :: $2 }
  | LPAREN terms RPAREN         { [make_APP $2] }
  | LPAREN terms RPAREN terms   { (make_APP $2) :: $4 } 
;

term:
  | NAME     { CONST ($1) }
  | VAR      { VAR {str = $1; id = 0; tag = LOG; ts = 0; lts = 0} }  
  | STRING   { STRING ($1) }
;

subexp:
  | NAME { CONST ($1) }
;

%%

