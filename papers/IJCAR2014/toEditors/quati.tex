\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{comment}
\usepackage{pdflscape}
\usepackage[textsize=scriptsize, textwidth=2.2cm]{todonotes}
\usepackage{booktabs}
%\bibliographystyle{alpha}
% \bibliographystyle{abbrv}
\usepackage{times}

\usepackage{color}
\definecolor{darkred}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkblue}{rgb}{0,0,0.5}
\usepackage[colorlinks=true,linkcolor=red,citecolor=red]{hyperref}
\usepackage{url}
    \hypersetup{colorlinks,urlcolor=darkblue}


\newcommand\tsl[1]{#1}
\newcommand{\elin}[2]{\ensuremath{{\tsl{unitctx}(\ensuremath{#1}, \ensuremath{#2})}}}
\newcommand{\emp}[1]{\ensuremath{{\tsl{emp}(\ensuremath{#1})}}}
\newcommand{\eqctx}[2]{\ensuremath{{\tsl{eqctx}(\ensuremath{#1},\ensuremath{#2})}}}
\newcommand{\union}[3]{\ensuremath{{\tsl{union}(\ensuremath{#1},\ensuremath{#2},\ensuremath{ #3})}}}
\newcommand{\In}[2]{\ensuremath{\tsl{in}(\ensuremath{#1},\ensuremath{#2})}}
\newcommand{\Equ}[2]{\ensuremath{\tsl{Equ}(\ensuremath{#1},\ensuremath{#2})}}
\newcommand{\unions}[2]{\ensuremath{\tsl{Unions}(\ensuremath{#1},\ensuremath{#2})}}
\newcommand{\equal}[2]{\ensuremath{\tsl{Equal}(\ensuremath{#1},\ensuremath{#2})}}
\newcommand{\equalCtx}[2]{\ensuremath{\tsl{EqualCtx}(\ensuremath{#1},\ensuremath{#2})}}

\newcommand\Pscr{\mathcal{P}}
\newcommand{\eg}{{\em e.g.}}
\newcommand{\ie}{{\em i.e.}}
\newcommand{\etal}{\emph{et al.}}
\newcommand{\cf}{{\em cf.}}
\newcommand{\tup}[1]{\langle#1\rangle}

\newcommand{\nbang}[1]{\hbox{$!^{#1}$}}
\newcommand{\nquest}[1]{\hbox{$?^{#1}$}}

% For Quati's latex output
\newcommand{\ndots}[1]{\stackrel{\vcenter{\hbox{$\scriptstyle :$}\vskip-.35ex}}
   {\hbox {$ \scriptstyle {#1}$}}}

\title{Quati: An Automated Tool for Proving Permutation Lemmas}
\author{Vivek Nigam\inst{1} \and Giselle Reis\inst{2} \and Leonardo Lima\inst{1}}

\institute{Universidade Federal da Para\'{i}ba, Brazil
\and Technische Universit\"{a}t Wien, Austria
}

%% NOTE: 7 pages tops

\begin{document}
\maketitle

\begin{abstract}
The proof of many foundational results in structural proof theory, such as the
admissibility of the cut rule and the completeness of the focusing discipline,
rely on permutation lemmas. It is often a tedious and error prone task to prove
such lemmas as they involve many cases. This paper describes the tool Quati
which is an automated tool capable of proving a wide range of inference rule
permutations for a great number of proof systems. Given a proof system
specification in the form of a theory in linear logic with subexponentials,
Quati outputs in \LaTeX\ the permutation transformations for which it was able
to prove correctness and also the 
possible derivations for which it was not able to do so. As illustrated in this
paper, Quati's output is very similar to proof derivation figures one would
normally find in a proof theory book. 
\end{abstract}

\vspace{-2mm}
\section{Introduction}

Permutation lemmas play an important role in proof theory. Many foundational
results about proof systems rely on the fact that some rules
permute over others. For instance, permutation lemmas are used in Gentzen-style 
cut-elimination proofs~\cite{gentzen35}, 
the completeness proof of focusing disciplines~\cite{andreoli92jlc,miller07cslb}, 
and the proof of Herbrand's theorem~\cite{herbrand30phd}.

Proving permutation lemmas, however, is often a tedious and error-prone task as there are normally many 
cases to consider. As an example, consider the case of permuting $\vee_l$ over $\rightarrow_l$ in
the intuitionistic calculus LJ. In order to show whether these two
rules permute, one needs to check \emph{every possible case} in which
$\rightarrow_l$ occurs above $\vee_l$ in a derivation. When using a
multiplicative calculus, there are four possibilities for such derivation, two
allow a permutation of the rules while the other two do not.
% \footnote{In an additive calculus there are three possibilities, only one of them allow a
% permutation.} 
Here's one of each:
%% -> l / v l
\vspace{-4mm}

{\scriptsize
\[
\infer[\vee_l]{\Gamma, \Gamma', \Gamma'', A \rightarrow B , P \vee Q \vdash F}{
  \deduce{\Gamma, P \vdash F}{\varphi_1\vspace{0.2cm}}
  &
  \infer[\rightarrow_l]{\Gamma', \Gamma'', A \rightarrow B , Q \vdash F}{
    \deduce{\Gamma' \vdash A}{\varphi_2\vspace{0.2cm}}
    &
    \deduce{\Gamma'', Q, B \vdash F}{\varphi_3\vspace{0.2cm}}
  }
}
\quad\rightsquigarrow\quad
\infer[\rightarrow_l]{\Gamma, \Gamma', \Gamma'', P \vee Q, A \rightarrow B
\vdash F}{
  \deduce{\Gamma' \vdash A}{\varphi_2\vspace{0.2cm}}
  &
  \infer[\vee_l]{\Gamma, \Gamma'', P \vee Q, B \vdash F}{
    \deduce{\Gamma, P \vdash F}{\varphi_1\vspace{0.2cm}}
    &
    \deduce{\Gamma'', B, Q \vdash F}{\varphi_3\vspace{0.2cm}}
  }
}
\]
}
%% -> l / v l
% \vspace{-2mm}
{\scriptsize
\[
\infer[\vee_l]{\Gamma, \Gamma', \Gamma'', A \rightarrow B , P \vee Q \vdash F}{
  \deduce{\Gamma, P \vdash F}{\varphi_1\vspace{0.2cm}}
  &
  \infer[\rightarrow_l]{\Gamma', \Gamma'', A \rightarrow B , Q \vdash F}{
    \deduce{\Gamma', Q \vdash A}{\varphi_2\vspace{0.2cm}}
    &
    \deduce{\Gamma'', B \vdash F}{\varphi_3\vspace{0.2cm}}
  }
}
\quad\rightsquigarrow\quad
?
\]
}%
The combinatorial nature of proving permutation lemmas can be observed in
this example. While there are ``only'' four cases to consider for this pair of rules, for
proving the completeness of the focusing discipline, one needs to study which
permutations are allowed and therefore all pairs of rules need to be
considered~\cite{miller07cslb}.
Moreover, the fact that the cases are rarely documented makes it hard for others to check the
correctness of the transformations. For instance, the cut-elimination result for
bi-intuitionistic logic given by Rauszer \cite{rauszer74studia}
was later found to be incorrect \cite{crolard01tcs} exactly because one of the
permutation lemmas was not true. Therefore, an automated tool to check for these lemmas
would be of great help. This paper introduces such a tool called
Quati.\footnote{Quati is a mammal from the raccoon family native to
South America. Its name comes from the Tupi-guarani, a language
spoken by native indians in Brazil, and means ``long nose''.}

While here we will restrict ourselves to simply illustrate Quati's
functionalities and implementation design, we observe that its underlying theory
is described in the papers~\cite{nigam.jlc,nigam13iclp,nigam14ebl}. We briefly
review this body of work.  
 
In~\cite{nigam13iclp}, we show how to reduce the problem of proving permutation
lemmas to solving an answer-set program~\cite{gelfond90iclp}. That is, given a proof
system $\Pscr$ satisfying some properties, we reduce the problem 
of checking whether a rule $r_1$ in $\Pscr$ always permutes over $r_2$ in
$\Pscr$ to solving an answer-set program. Each solution of this program
corresponds to one possible permutation case. This result sets the foundations 
for Quati.

However, the exact language in which proof systems are specified was not dealt
in~\cite{nigam13iclp}. It was subject of the paper~\cite{nigam.jlc} which
shows that a great number of proof systems for different logics (\eg, linear,
intuitionistic, classical, modal logics) can be specified as theories in linear
logic with subexponentials (SELL)~\cite{nigam09ppdp}. These specifications are shown to
have a strong adequacy, namely, \emph{on the level of
derivations}~\cite{nigam10jar}, meaning that there is a one to one
correspondence of derivations in the specified logic (object logic) to derivations in linear
logic with subexponentials. Moreover, \cite{nigam.jlc} also shows how to check whether 
proof systems specified in SELL admit cut-elimination. This lead to the tool 
TATU\footnote{\url{https://www.logic.at/staff/giselle/tatu/}}. Therefore, SELL is
a suitable framework for specifying proof systems. 

Finally, in the workshop paper~\cite{nigam14ebl}, we show how to integrate the material
in \cite{nigam13iclp} and \cite{nigam.jlc}. Given a proof system specified in
SELL, we reduce the problem of checking whether a rule permutes over another to
an answer-set program.
%In particular, we show how to reduce,
%to solving an answer-set program, the problem of checking whether a rule permutes
%over another when given a proof system specified in SELL. 
%Moreover, we also discuss in \cite{nigam14ebl} how to extract
In the same paper, we also discuss how to extract
proof derivation figures similar to those shown in a standard proof theory
book~\cite{troelstra96bpt} from the solutions of the generated answer-set programs. 

Quati is the result of this series of papers. This paper is organized as follows: Section~\ref{sec:quati} describes
Quati's syntax and its features, while Section~\ref{sec:impl} describes its implementation.
In Section~\ref{sec:conc} we end by pointing out future work.

\vspace{-4mm}

\section{Quati at Work}
\label{sec:quati}

Throughout this section, we will use the specification for the
intuitionistic logic's multi-conclusion calculus MLJ~\cite{maehara54nmj} as our running 
example. First we specify Quati's syntax and then its features. 
% In the Appendix
% you can find a step-by-step user session of the Quati system for this example as well as the proof system MLJ. 

\vspace{-2mm}

\subsection{Syntax}

\begin{figure}[t]
{\small
\[
\begin{array}{lcl}
Side ::= \texttt{lft} \;\;|\;\; \texttt{rght} \quad 
CtxType ::=  \texttt{many} \;\;|\;\; \texttt{single} \quad
SubType ::=  \texttt{unb} \;\;|\;\; \texttt{lin} \\[2pt]
SubSig ::= SubDecl \;\; SubSpec \;\; SubRel \\[2pt]
SubDecl ::= \texttt{subexp} \tup{String} \tup{SubType}.\\[2pt]
SubSpec ::= \texttt{subexpctx} \tup{String} \tup{CtxType} \tup{Side}.\\[2pt]
SubRel ::= \texttt{subexprel} \tup{String} \texttt{<} \tup{String}. \\[2pt]
Bipoles ::= (\texttt{not} \tup{Atoms}) \texttt{*} \tup{BodyPos}. \\[2pt]
BodyPos ::=\texttt{one} \;\;|\;\; BodyNeg \;\;|\;\; \texttt{[}\tup{String}\texttt{]bang} BodyNeg \;\;|\;\;\\ 
        \qquad\qquad BodyPos \texttt{*} BodyPos \;\;|\;\; BodyPos \texttt{+} BodyPos \\[2pt]
BodyNeg ::= \texttt{top} \;\;|\;\; \texttt{bot} \;\;|\;\; \tup{MarkAtoms} \;\;|\;\; \tup{BodyNeg}|\tup{BodyNeg} \;\;|\;\; \\
        \qquad \qquad \tup{BodyNeg} \texttt{\&} \tup{BodyNeg}\\[2pt]
Atoms ::=\tup{Side} \tup{Form} \qquad MarkAtoms ::=  \texttt{[}\tup{String}\texttt{]?} \tup{Atoms} \\
\end{array}
\]
% \begin{align*}
% SubSig &::= SubDecl \;\; SubSpec \;\; SubRel \\
% SubDecl &::= \texttt{subexp} \tup{String} \tup{SubType}.\\
% SubSpec &::= \texttt{subexpctx} \tup{String} \tup{CtxType} \tup{Side}.\\
% SubRel &::= \texttt{subexprel} \tup{String} \texttt{<} \tup{String}. \\
% Side &::= \texttt{lft} \;\;|\;\; \texttt{rght} \\
% CtxType &::=  \texttt{many} \;\;|\;\; \texttt{single} \\
% SubType &::=  \texttt{unb} \;\;|\;\; \texttt{lin} \\
% Bipoles &::= (\texttt{not} \tup{Atoms}) \texttt{*} \tup{BodyPos}. \\
% Atoms &::= \tup{Side} \tup{Form} \\
% BodyPos &::= \texttt{one} \;\;|\;\; BodyNeg \;\;|\;\; \texttt{[}\tup{String}\texttt{]bang} BodyNeg \;\;|\;\;\\ 
%         & BodyPos \texttt{*} BodyPos \;\;|\;\; BodyPos \texttt{+} BodyPos \\
% BodyNeg &::= \texttt{top} \;\;|\;\; \texttt{bot} \;\;|\;\; \tup{MarkAtoms} \;\;|\;\; \tup{BodyNeg}|\tup{BodyNeg} \;\;|\;\; \\
%         & \tup{BodyNeg} \texttt{\&} \tup{BodyNeg}\\
% MarkAtoms &::= \texttt{[}\tup{String}\texttt{]?} \tup{Atoms} 
% \end{align*}
}
\vspace{-4mm}
% \textbf{VN: We need to add more constructs}
\caption{Here $Form$ is a term of type \texttt{form}.} 
\label{fig:syntax}
\begin{center}
\begin{tabular}{c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c@{\quad}c}
\toprule
\texttt{*} : $\otimes$ & \texttt{+} : $\oplus$ & \texttt{\&} : $\&$ & \texttt{|} : $\bindnasrepma$ & \texttt{[i]bang} : $!^i$ &
\texttt{one} : $1$ &  \texttt{top} : $\top$ & \texttt{bot} : $\bot$ & \texttt{[i]?} : $?^i$ \\
\bottomrule
\end{tabular}
\end{center}
\vspace{-4mm}
\caption{Syntax for the linear logic connectives.}
\label{fig:syntax_ll}
\vspace{-4mm}
\end{figure}

Quati's underlying logic, linear logic with subexponentials
(SELL)~\cite{nigam09ppdp}, is a powerful framework for the specification of proof systems. 
Subexponentials, written $\nbang{\ell}$, $\nquest{\ell}$, arise from the
observation that the linear logic exponentials are not canonical (see
\cite{nigam.jlc} for an extensive discussion). It is known that these operators
greatly increase
the expressiveness of the system when compared to linear logic. For instance,
subexponentials can be used to represent contexts of proof
systems~\cite{nigam.jlc}, to mark the epistemic state of
agents~\cite{nigam12lics}, or to specify locations in sequential
computations~\cite{nigam09ppdp}. 
The main feature of subexponentials is that they are organized in a pre-order, $\preceq$, which specifies
the provability relation among them. 
In \cite{nigam.jlc}, we have shown that a great number of proof systems for linear, classic, intuitionistic and 
modal logics can be specified in SELL with a strong level of adequacy. 
%
Another important reason for using SELL as specification language is that one can also use 
other available tools, such as the tool TATU which is capable of checking whether a proof system 
specified in SELL admits cut-elimination.

A Quati program is a SELL theory with some more annotations. Its syntax is given
in Figure~\ref{fig:syntax} and explained in detail  
by using our running example MLJ.
%the inference rules of the multiconclusion sequent
%calculus for intuitionistic logic~\cite{maehara54nmj}, or MLJ.
%
A Quati program consists of two files: (1) a \emph{type signature} file, with
suffix \texttt{.sig} and (2) a specification file with suffix \texttt{.pl} consisting of two parts: (a) a
\emph{subexponential signature} and (b) the rules' specifications or
\emph{bipoles}.

\vspace{-2mm}

\paragraph{Type signature}
%
This file contains type and kind declarations of the object
logic's elements. The kind \texttt{form} is built-in and
represent the type of formulas of the object logic. In general, only
the connectives' types need to be declared in this file:
%Here is an example:
\vspace{-1mm}

{\small
\begin{verbatim}
%%%%%%%%%%%%%%%%%%% Signature %%%%%%%%%%%%%%%%%%%%
type imp form -> form -> form.
\end{verbatim}
}

\paragraph{Subexponential signature}
%
The following subexponential signature is used for specifying the proof system MLJ:
\vspace{-1mm}

{\small
\begin{verbatim}
%%%%%%%%%%%%%%% Subexponential Signature %%%%%%%%%%%%%%%%%
subexp l unb.                       subexp r unb.            
subexpctx l many lft.               subexpctx r many rght.
subexprel l > r
\end{verbatim}
}

Intuitively, one subexponential corresponds to one context of the object logic sequent.\footnote{There are 
some specifications where a subexponential is used to capture the structural properties of the proof 
system and therefore does not necessarily correspond to a context in the object logic. See \cite{nigam.jlc}
for more on this.}
MLJ has only two contexts, one to the left and another to the right side of the
sequent, thus we use two subexponentials
\texttt{l} and \texttt{r}. Moreover, as both contexts (to the left and right) behave classically in MLJ, 
we specify \texttt{l} and \texttt{r} to be unbounded, denoted by \texttt{unb}. In contrast, 
the specification of LJ would specify the subexponential \texttt{r} to be linear, as the right side of LJ's 
sequents behaves linearly.

The commands \texttt{subexpctx l many lft.} and  \texttt{subexpctx r many rght.} are not formally needed for specifying proof systems, 
but as discussed 
in \cite{nigam14ebl}, they are needed in order to improve the visualization of the proof rules. 
In particular, the former specifies that the context corresponding to the subexponential \texttt{l} contains 
only formulas of the left side of the sequent, denoted by \texttt{lft}, and may contain many formulas, denoted 
by \texttt{many}. In contrast, as the context to the right side of LJ sequents has only one formula, the 
subexponential \texttt{r} for that system would be annotated with \texttt{single}.

The pre-order among the subexponentials is specified on the last line using the
keyword \texttt{subexprel}.

\vspace{-2mm}

\paragraph{Bipoles}
%
The second part of the \texttt{.pl} file is composed by $bipoles$. The concrete syntax for SELL connectives
is depicted in Figure~\ref{fig:syntax_ll}. The class of $bipole$ formulas often
appear in proof theory literature due to its good focusing
behaviour~\cite{andreoli92jlc}. The following bipoles specify, 
respectively, the left and right implication introduction rules~\cite{nigam.jlc}. The capital 
letters are assumed to be existentially quantified.
\vspace{-1mm}

% TODO: explain the division into rule types??? No. No space.
{\small
\begin{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%% Bipoles %%%%%%%%%%%%%%%%%%%%%%%%%%%
% Implication
(not (lft (imp A B))) * (([r]? (rght A)) * ([l]? (lft B))).
(not (rght (imp A B))) * [l]bang (([l]? (lft A)) | ([r]? (rght B))).
\end{verbatim}
}

The head of these bipoles, formulas \texttt{(not (lft (imp A B)))} and
\texttt{(not (rght (imp A B)))}, specify that an implication formula to, respectively, 
the left and right-hand-side is introduced. The body specifies the premises of these
rules. For instance, the first bipole specifies that its corresponding inference rules
has two premises because of the branching caused by the  
tensor \texttt{*} appearing in the body of its rule, while
the second has only one premise as no branching is required. 
The interesting bit is the $!^l$ (\texttt{[l]bang}) in the second bipole specifying that the 
context of the subexponential \texttt{r} should be weakened as \texttt{l > r}.
In fact, by using advanced proof theoretic machinery, namely focusing~\cite{andreoli92jlc}, 
we can make this intuition precise in the sense. We refer to~\cite{nigam.jlc} for more details
on encodings.

% \vspace{-3mm}

\subsection{Features}

Quati has two main features: (1) It can construct the corresponding inference rule(s) associated
to a SELL formula; and (2) it can prove permutation lemmas. We illustrate these features with 
the specification of MLJ implication introduction rules shown above.

% \vspace{-2mm}

\paragraph{Rule Construction} Proving the adequacy theorems for a given SELL specification is also 
error-prone. As detailed in~\cite{nigam.jlc}, to prove (strong) adequacy we need to show that all 
the possible focused derivations that introduce a formula in the specification correspond to 
an inference rule of the proof system being specified. Quati automates the proof of such 
adequacy theorems by constructing from a bipole the corresponding inference rule. 
To do so, Quati uses the machinery described in \cite{nigam13iclp,nigam14ebl} reducing
this problem to the problem of solving answer-set programs. 

For the MLJ specification given above, one can use the command \texttt{\#rule} in the command 
line and select a SELL bipole in the loaded specification. Then Quati generates
a \LaTeX\ document containing all possible inference rules that correspond to that bipole. If we select the bipole used to specify 
MLJ's implication right rule, Quati outputs the \LaTeX\ code for the following figure:
\vspace{-3mm}

{\small
\[
\cfrac{ \ndots{l} \Gamma_{l}^{0}, a \vdash  \ndots{r} b}
{ \ndots{l} \Gamma_{l}^{0} \vdash  \ndots{r} \Delta_{r}^{0}, imp (a) (b) } \;\; imp_{R}
\]
}

Notice that this rule looks very similar to MLJ's implication right introduction rule shown in any proof theory 
textbook. The context $\Delta_{r}^{0}$ is erased in the premise. The $\ndots{l}$ and $\ndots{r}$ are used to 
delimit the contexts for the subexponentials \texttt{l} and \texttt{r}, respectively. Quati uses the subexponential 
specification to infer that the context for \texttt{l} (resp. for \texttt{r})
should only be on the left-hand-side (resp. right-hand-side) of the sequent.

Under the hood, Quati is constructing the focused derivation~\cite{andreoli92jlc} that introduces such 
a SELL bipole as described in \cite{nigam.jlc}. This can be observed by using the command 
\texttt{\#bipole}. For the same SELL bipole used above, Quati returns
the \LaTeX\ code for the following figure, corresponding to its focused
derivation:
%of the SELL bipole:
\vspace{-4mm}


{\scriptsize\[\cfrac{\cfrac{\cfrac{}
{\Gamma_{ gamma}^{4} ; \Gamma_{r}^{4} ; \Gamma_{l}^{3} ; \Gamma_{ infty}^{1} ;  \Downarrow \neg rght (imp (a) (b) )  } \quad \cfrac{\cfrac{\cfrac{\cfrac{\Gamma_{ gamma}^{5} ; \Gamma_{r}^{7} ; \Gamma_{l}^{5} ; \Gamma_{ infty}^{1} ;  \Uparrow }
{\Gamma_{ gamma}^{5} ; \Gamma_{r}^{5} ; \Gamma_{l}^{5} ; \Gamma_{ infty}^{1} ;  \Uparrow  ?^{r} rght (b)  }}
{\Gamma_{ gamma}^{5} ; \Gamma_{r}^{5} ; \Gamma_{l}^{3} ; \Gamma_{ infty}^{1} ;  \Uparrow  ?^{l} lft (a)  ::  ?^{r} rght (b) }}
{\Gamma_{ gamma}^{5} ; \Gamma_{r}^{5} ; \Gamma_{l}^{3} ; \Gamma_{ infty}^{1} ;  \Uparrow  ?^{l} lft (a)  \bindnasrepma  ?^{r} rght (b)  }}
{\Gamma_{ gamma}^{5} ; \Gamma_{r}^{4} ; \Gamma_{l}^{3} ; \Gamma_{ infty}^{1} ;  \Downarrow  !^{l}  ?^{l} lft (a)  \bindnasrepma  ?^{r} rght (b)  }}
{\Gamma_{ gamma}^{3} ; \Gamma_{r}^{4} ; \Gamma_{l}^{3} ; \Gamma_{ infty}^{1} ;  \Downarrow \neg rght (imp (a) (b) )  \otimes  !^{l}  ?^{l} lft (a)  \bindnasrepma  ?^{r} rght (b) }}
{\Gamma_{ gamma}^{3} ; \Gamma_{r}^{4} ; \Gamma_{l}^{3} ; \Gamma_{ infty}^{1} ; \Uparrow }\]}


\vspace{-2mm}

\paragraph{Rule Permutation}
As described in the Introduction, Quati can be used to prove permutation lemmas. The command \texttt{\#permute} 
checks whether the permutation of two selected rules is always allowed or not. Quati outputs, again in \LaTeX, the cases for
which it was able to find the permutation and the cases for which it was not able to find a permutation. For example, when Quati 
checks whether MLJ's implication left introduction rule permutes over MLJ's
implication right introduction, it correctly finds two possible
permutation cases and it cannot find one of the cases for which is indeed not possible. We show one of the cases (reformatted to fit the page margins):
\vspace{-3mm}

{\scriptsize
\[
\begin{array}{ll}
\cfrac{\cfrac{ \ndots{l} \Gamma_{l}^{0}, imp (a) (b) , c \vdash  \ndots{r} d}
{ \ndots{l} \Gamma_{l}^{0}, imp (a) (b)  \vdash  \ndots{r} \Delta_{r}^{0}, imp (c) (d) , a} \;\; imp_{R}
\quad
 \ndots{l} \Gamma_{l}^{0}, imp (a) (b) , b \vdash  \ndots{r} \Delta_{r}^{0}, imp (c) (d) }
{ \ndots{l} \Gamma_{l}^{0}, imp (a) (b)  \vdash  \ndots{r} \Delta_{r}^{0}, imp (c) (d) } \;\; imp_{L}\\\\
\qquad \qquad \qquad \qquad \qquad \qquad \qquad \quad\rightsquigarrow\quad
\cfrac{\cfrac{ \ndots{l} \Gamma_{l}^{7}, imp (a) (b) , c \vdash  \ndots{r} a, d
\quad
 \ndots{l} \Gamma_{l}^{7}, imp (a) (b) , c, b \vdash  \ndots{r} d}
{ \ndots{l} \Gamma_{l}^{7}, imp (a) (b) , c \vdash  \ndots{r} d} \;\; imp_{L}}
{ \ndots{l} \Gamma_{l}^{7}, imp (a) (b)  \vdash  \ndots{r} \Delta_{r}^{9}, imp (c) (d) } \;\; imp_{R}
\end{array}
\]
}

Once again, this proof figure is very similar to the proof figure that one would find in a standard proof theory textbook.
Notice that it uses the fact that the contexts are unbounded, i.e. formulas can
be contracted or weakened, to infer the permutation above (see \cite{nigam13iclp} for 
more discussion on how this works).

\section{Implementation Details}
\label{sec:impl}

Quati is implemented in OCaml\footnote{\url{http://ocaml.org/}} and makes use of
DLV\footnote{\url{http://www.dlvsystem.com/dlv/}} externally to compute minimal models for the
answer-set programs generated. It is part of a bigger project, called
\texttt{sellf}\footnote{\url{https://code.google.com/p/sellf/}} which also includes the
machinery for TATU mentioned above. The following diagram provides an overview of
the main modules in \texttt{sellf} used by Quati for checking permutations.

\begin{center}
% \includegraphics[width=7.5cm]{figures/modulos.pdf}
\includegraphics[width=10cm]{figures/modulos-simple.pdf} 
\end{center}

% 
% \begin{figure}
% TODO: module's figure
% \caption{}
% \label{fig:modules}
% \end{figure}

The basic data structure, defined in the module \texttt{Types}, is linear logic
formulas with subexponentials. The bipoles in Quati are represented by
\emph{proof tree schemas}, defined in the module \texttt{ProofTreeSchema}, which
uses the modules \texttt{SequentSchema} and \texttt{ContextSchema}. As the name
suggests, these are schematic representations of proof trees, sequents and
contexts that use generic contexts~\cite{nigam13iclp} to represent possibly
non-empty sets of formulas. 
%The generic contexts are implemented as pairs
%\texttt{string * int}, where the first element is the name of the context (or
%subexponential) and the second is a unique identifier. 
The constraints that will
later compose the answer-set program are implemented in the module \texttt{Constraints}.
The application of linear logic rules with constraints is implemented in the
\texttt{ProofTreeSchema} module.
%
The computation of possible bipoles of a formula is in the module
\texttt{Bipole}. The \texttt{Permutation} module makes use of the bipole
generation to construct the derivations of two rules. Given the
constraints of a derivation, module \texttt{Dlv} contains the code
for executing DLV externally, parsing the result and returning the minimal
models. 
%
The translation of a proof tree schema and constraints into an object logic
derivation is done in the \texttt{OlRule} module. It contains data structures to
represent proof trees, sequents and contexts of an object logic and the
rewriting algorithm described in~\cite{nigam13iclp} (module \texttt{Derivation}).

%\textbf{Add a paragraph on the results, such as time to compute, which systems, etc.}
Quati was tested using some proof systems including LK, LJ, MLJ, LL, S4, G1m and
LAX. On
most cases, each permutation lemma can be checked in less than one second. The
implementation can be downloaded at
\begin{center}
\url{http://www.logic.at/staff/giselle/quati}. 
\end{center}

\vspace{-2mm}

\section{Conclusions and Future Work}
\label{sec:conc}
This paper introduced Quati, an automated tool for proving permutation lemmas. Besides briefly 
commenting on its implementation, we illustrated its syntax, usage and features. Besides MLJ, in the download
one can find the specification of all proof systems tested, as well as system
requirements and installation instructions.
%a number of implemented systems, such as systems for linear logic, intuitionistic logic, s4, 
%and others. 

There are several directions we are currently investigating for continuing this work. One is to come up with 
more graphical ways of writing proof systems and how to translate such representations into SELL specifications. 
Another possibility is the derivation of completeness of focusing
strategies in an automated fashion, since such theorems rely heavily on
permutation lemmas.
%Since the proof of the completeness theorem of focusing strategies rely heavily on permutation lemmas, we are 
%currently investigating ways to derive such theorems in an automated fashion. 
Finally, we are investigating ways to construct machine-readable proof objects for permutation lemmas.

\vspace{-2mm}

\bibliographystyle{abbrv}
% \bibliography{../master}
\begin{thebibliography}{10}

\bibitem{andreoli92jlc}
J.-M. Andreoli.
\newblock Logic programming with focusing proofs in linear logic.
\newblock {\em J. of Logic and Computation}, 2(3):297--347, 1992.

\bibitem{crolard01tcs}
T.~Crolard.
\newblock Subtractive logic.
\newblock {\em Theor. Comput. Sci.}, 254(1-2):151--185, 2001.

\bibitem{gelfond90iclp}
M.~Gelfond and V.~Lifschitz.
\newblock Logic programs with classical negation.
\newblock In {\em ICLP}, 1990.

\bibitem{gentzen35}
G.~Gentzen.
\newblock Investigations into logical deductions.
\newblock In {\em {The Collected Papers of Gerhard
  Gentzen}}, 1969.

\bibitem{herbrand30phd}
J.~Herbrand.
\newblock {\em Recherches sur la Th{\'e}orie de la {D}{\'e}monstration}.
\newblock PhD thesis, 1930.

\bibitem{maehara54nmj}
S.~Maehara.
\newblock Eine darstellung der intuitionistischen logik in der klassischen.
\newblock {\em Nagoya Mathematical Journal}, pages 45--64, 1954.

\bibitem{miller07cslb}
D.~Miller and A.~Saurin.
\newblock From proofs to focused proofs: a modular proof of focalization in
  linear logic.
\newblock In {\em CSL}, 2007.

\bibitem{nigam.jlc}
V.~Nigam, , E.~Pimentel, and G.~Reis.
\newblock An extended framework for specifying and reasoning about proof
  systems.
\newblock Accepted to Journal of Logic and Computation. Available at 
\url{http://www.nigam.info/docs/modal-sellf.pdf}

\bibitem{nigam14ebl}
V.~Nigam, , G.~Reis, and L.~Lima.
\newblock Quati: From linear logic specifications to inference rules (extended
  abstract).
\newblock Brazilian Logic Conference (EBL), 2014. Available at
\url{http://www.nigam.info/docs/ebl14.pdf}

\bibitem{nigam12lics}
V.~Nigam.
\newblock On the complexity of linear authorization logics.
\newblock In {\em LICS}, 2012.

\bibitem{nigam09ppdp}
V.~Nigam and D.~Miller.
\newblock Algorithmic specifications in linear logic with subexponentials.
\newblock In PPDP, 2009.

\bibitem{nigam10jar}
V.~Nigam and D.~Miller.
\newblock A framework for proof systems.
\newblock {\em J. Autom. Reasoning}, 45(2):157--188, 2010.

\bibitem{nigam13iclp}
V.~Nigam, G.~Reis, and L.~Lima.
\newblock Checking proof transformations with {ASP}.
\newblock In {\em ICLP (Technical Communications)}, 2013.

\bibitem{rauszer74studia}
C.~Rauszer.
\newblock A formalization of the propositional calculus h-b logic.
\newblock {\em Studia Logica}, 1974.

\bibitem{troelstra96bpt}
A.~S. Troelstra and H.~Schwichtenberg.
\newblock {\em Basic Proof Theory}.
\newblock 1996.

\end{thebibliography}

\end{document}

