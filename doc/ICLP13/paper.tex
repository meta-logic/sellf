% new_TLP2egui.tex / guide for TLP
% v2.12, released 23-apr-2003
%   (based on JFP2egui.tex v1.01) and tlp2egui.tex
% Copyright (C) 2000,2001,2002,2003, 2012 Cambridge University Press

\NeedsTeXFormat{LaTeX2e}

\documentclass{new_tlp}

\usepackage{../myproof}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{color}
\usepackage{times}
\usepackage{../mycommands}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{alltt}
\usepackage{booktabs}
\usepackage{lineno}
\bibliographystyle{abbrv}
\usepackage{algorithm}
\usepackage{algorithmic}
\RequirePackage{txfonts}


\newcommand\plus{\oplus}
\renewcommand\lpar{\mathrel{\bindnasrepma}}

\usepackage{lineno}
\newcommand\SELL{\tsl{SELL}}
\newcommand\SELLF{\tsl{SELLF}}
\newcommand{\etal}{\emph{et al.}}
\newcommand\lra{\longrightarrow}

\newenvironment{changemargin}[2]{% 
  \begin{list}{}{% 
    \setlength{\topsep}{0pt}% 
    \setlength{\leftmargin}{#1}% 
    \setlength{\rightmargin}{#2}% 
    \setlength{\listparindent}{\parindent}% 
    \setlength{\itemindent}{\parindent}% 
    \setlength{\parsep}{\parskip}% 
  }% 
\item[]}{\end{list}} 

\DeclareMathAlphabet{\mathsl}{OT1}{cmr}{m}{sl}

 \newtheorem{theorem}{Theorem} 
 \newtheorem{definition}[theorem]{Definition}
 \newtheorem{lemma}[theorem]{Lemma}
 \newtheorem{proposition}[theorem]{Proposition}
 \newtheorem{corollary}[theorem]{Corollary}
 \newenvironment{remark}{\noindent \textbf{Remark}\quad}{}

%\newenvironment{Paragraph}[1]{%\vspace{-3mm} \paragraph{#1}}
%\newenvironment{Paragraph}[1]{\vspace{2mm}\noindent\textbf{#1}}
\newenvironment{Paragraph}[1]{\paragraph{#1}}

\newcommand\vSpace{\vspace{-0mm}}


%%% Macros for the guide only %%%
\hyphenation{either}
\providecommand\AMSLaTeX{AMS\,\LaTeX}
\newcommand\etc{\emph{etc.}}
\newcommand\bcmdtab{\noindent\bgroup\tabcolsep=0pt%
  \begin{tabular}{@{}p{10pc}@{}p{20pc}@{}}}
\newcommand\ecmdtab{\end{tabular}\egroup}
\newcommand\rch[1]{$\longrightarrow\rlap{$#1$}$\hspace{1em}}

  \title[International Conference on Logic Programming]
        {Checking Proof Transformations with ASP}

  \author[Vivek Nigam, Leonardo Lima and Gisele Reis]
         {Vivek Nigam and Leonardo Lima\\
         Universidade Federal da Para\'iba, Brazil\\
         \email{\{vivek.nigam, leonardo.alfs\}@gmail.com} 
         \and 
         Gisele Reis\\
         Technische Universit\"at Wien, Austria\\
         \email{giselle@logic.at}}


\begin{document}

% \label{firstpage}

\maketitle

  \begin{abstract}
  Proof transformation is an important proof theoretic technique that has
been used for showing a number of foundational results about proof
systems. For instance, it is used when showing the admissibility of the
cut-rule and the completeness of proof search strategies, such as uniform
provability and the focusing discipline. However, in order to check the
validity of a proof transformation, such as when one inference
rule permutes over another, one needs to consider the combination of how 
inference rules may be applied. Therefore, checking the correctness of proof
transformations is prone to human error. This paper offers the means to
automatize the check of such transformations by using Answer Set Programming (ASP). 
  \end{abstract}

  \begin{keywords}
    Answer Set Programming, Automatic Verification, Logical Frameworks
  \end{keywords}

% \tableofcontents

\section{Introduction}
Proof transformation is a powerful technique used in proving many
foundational results about proof systems. For instance, one demonstrates
the admissibility of the cut-rule~\cite{gentzen35} by showing
how to transform a proof with cuts into a proof without cuts.
Similarly, in order to show the completeness of a proof search strategy,
such as uniform provability~\cite{miller91apal}  and the focusing
discipline~\cite{andreoli92jlc}, one demonstrates how to transform an
arbitrary (cut-free) proof into another (cut-free) proof that follows the
given proof search strategy, such as an uniform proof or a focused proof. 

However, it is often a tedious task to verify whether a proof
transformation is valid, specially when there is a great number of cases to
consider. For example, in the proof of completeness of the focusing
discipline, one needs to show that some rules permute over other
rules~\cite{miller07cslb}.
These results are called \emph{permutation lemmas} and they involve
a number of proof transformations. The following transformation is one of
the many cases that need to be considered: A linear logic~\cite{girard87tcs} proof ending with
the following derivation, where $\tensor_R$ is applied last,
{
\[
\infer[\tensor_R]{\Gamma, \Gamma' \vdash \Delta, \Delta', A\tensor B,
C\with
D}
{
{\Gamma \vdash \Delta, A}
&
\infer[\with_R]{\Gamma' \vdash \Delta', B, C\with D}
{
{\Gamma' \vdash \Delta', B, C}
&
{\Gamma' \vdash \Delta', B, D}
}
}
\]
}
can be transformed into another linear logic proof ending with the
following
derivation, where the $\with_R$ is applied last:
{
\[
\infer[\with_R]{\Gamma, \Gamma' \vdash \Delta, \Delta', A\tensor B, C\with
D}
{
\infer[\tensor_R]{\Gamma, \Gamma' \vdash \Delta, \Delta', A\tensor B, C}
{
{\Gamma \vdash \Delta, A}
&
{\Gamma' \vdash \Delta', B, C}
}
&
\infer[\tensor_R]{\Gamma, \Gamma' \vdash \Delta, \Delta', A\tensor B, D}
{
{\Gamma \vdash \Delta, A}
&
{ \Gamma' \vdash  \Delta', B, D}
}
}
\]
}%
The proof transformation above is one of the many cases required in showing
that any instance of a $\tensor_R$ rule can permute over any instance
of a $\with_R$. In
particular, to check the correctness of such transformation, one needs to
check that (Obligation 1) all rules are correctly applied and that (Obligation 2) the premises of
the latter derivation can be proved using the proofs introducing the
premises of the former derivation. For instance, in the case above, the
proof introducing the sequent $\Gamma \vdash \Delta, A$ in the former
derivation can be used twice in the latter derivation. Similar permutation 
lemmas also appear in the proof of cut-elimination, in particular, when 
transforming a proof with cuts into a proof with \emph{principal
cuts}~\cite{gentzen35}.\footnote{In fact, permutation lemmas compose a
great part of the cut-elimination proof, roughly half of the proof. See for
example the proof in \url{http://twelf.org/wiki/Admissibility_of_cut}.} 

Although one can check by hand the validity of such proof transformations,
this procedure is prone to human error as one they are \emph{combinatorial} by nature and 
therefore one can easily miss a case or another. For instance, the cut-elimination 
result for Bi-Intuitionistic logic~\cite{} given by XXX in \cite{} was later found to 
be incorrect~\cite{} exactly because one of the permutation lemmas was in fact not correct. 
A much better approach, therefore, is to automate the check of which proof transformations are always possible. 

As we demonstrate in this paper, Answer Set Programming (ASP)~\cite{gelfond90iclp} turned out to be very suitable
paradigm for checking the correctness of proof transformations. In our initial efforts, 
we attempted to use functional programming languages to check whether the Proof Obligations 1 and 2 
above are both satisfied. However, as illustrated above, these problems require a combinatorial
solution, for which the solution in ASP turned out to be a much simpler. In particular, we construct two Answer Set Programs 
(AS-Programs):
\begin{itemize}
 \item The first program, $\Tscr$, is constructed for a given inference
rule, $r$, and specifies the set of its valid instances. 
We show that $\Tscr$ is sound and complete in the sense
that its set of \emph{answer-sets} corresponds 
exactly to the set of all possible valid instances of the rule $r$, thus 
solving Obligation 1.

\item For two given object-level sequents, $\Sscr_1$ and $\Sscr_2$, the
second program, $\Pscr$, checks whether the sequent $\Sscr_2$ is provable,
when assuming that $\Sscr_1$ is also provable. In particular, we show that
if the program $\Pscr$ has at least one answer-set, then it is
possible to derive a proof of $\Sscr_2$ from a proof of $\Sscr_1$. This 
solves Obligation 2.
% This
% result can be interpreted as a soundness result. On the other hand, as we
% are using a linear logic framework, this problem can be reduced to the
% provability problem in linear logic, which is undecidable in
% general~\cite{lincoln90focs}. Hence, there is no hope for proving the
% completeness of our method. Nevertheless, our method did not
% fail to prove any of the permutation cases in our experiments with existing
% proof systems.
\end{itemize}
% we specify an Answer Set Program (AS-Program) that is only satisfiable if and only if a given (meta-)derivation 
% is indeed a derivation obtained by applying correctly the given inference rules, such as $\tensor_R$ and $\with_R$, 
% thus solving Obligation 1. In fact, each model of this AS-Program corresponds 
% to one possible valid derivation. Similarly, we also construct an AS-Program that solves Obligation 2, by checking whether
% the proof introducing a sequent, \eg, $\Gamma \vdash \Delta, A$, can be used to prove a premise of a
% given derivation.

Another main advantage of using ASP is that they enable the
use powerful off-the-shelf
provers~\cite{niemela97lpmnr,leone06tcl}. We
implemented a tool that takes the specification of a proof system and
checks automatically which inference rules of the object-system permute
over another rule. We use linear logic as specification language. As demonstrated
in \cite{nigam10jar,nigam11lsfa}, our linear logical framework allows for the encoding of 
a wide range of proof systems, such as proof systems for linear, intuitionistic, 
classical, and modal. Whenever the tool can find a valid permutation
it outputs the corresponding proof transformation,
and whenever it cannot show that a rule permutes over another, it outputs
the cases that it failed to find a valid permutation. 
We used this tool to show a number of proof
transformations. For instance, our tool checks all cases of the key
permutation lemmas
needed for showing the completeness of the focusing
discipline~\cite{andreoli92jlc} and uniform proofs~\cite{miller91apal}.
Up to our knowledge there is no such a tool yet available.


\section{Answer Set Programming}

\subsection{Checking the Validity of Derivations}

\subsection{Checking Provability Implication of Sequents}

\subsection{Putting all Together}

\section{Linear Logical Framework}

\section{Extracting Answer Set Programs}

\section{Tool and Experimental Results}

\section{Related and Future Work}


\bibliographystyle{plain}
\bibliography{../master}


\end{document}

% end of new_TLP2egui.tex
