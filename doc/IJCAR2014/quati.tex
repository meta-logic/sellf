\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage[textsize=scriptsize, textwidth=2.2cm]{todonotes}

\newcommand\tsl[1]{#1}
\newcommand{\elin}[2]{\ensuremath{{\tsl{unitctx}(\ensuremath{#1}, \ensuremath{#2})}}}
\newcommand{\emp}[1]{\ensuremath{{\tsl{emp}(\ensuremath{#1})}}}
\newcommand{\eqctx}[2]{\ensuremath{{\tsl{eqctx}(\ensuremath{#1},\ensuremath{#2})}}}
\newcommand{\union}[3]{\ensuremath{{\tsl{union}(\ensuremath{#1},\ensuremath{#2},\ensuremath{ #3})}}}
\newcommand{\In}[2]{\ensuremath{\tsl{in}(\ensuremath{#1},\ensuremath{#2})}}
\newcommand{\Equ}[2]{\ensuremath{\tsl{Equ}(\ensuremath{#1},\ensuremath{#2})}}
\newcommand{\unions}[2]{\ensuremath{\tsl{Unions}(\ensuremath{#1},\ensuremath{#2})}}
\newcommand{\equal}[2]{\ensuremath{\tsl{Equal}(\ensuremath{#1},\ensuremath{#2})}}
\newcommand{\equalCtx}[2]{\ensuremath{\tsl{EqualCtx}(\ensuremath{#1},\ensuremath{#2})}}

\newcommand\Pscr{\mathcal{P}}
\newcommand{\eg}{{\em e.g.}}
\newcommand{\ie}{{\em i.e.}}
\newcommand{\etal}{\emph{et al.}}
\newcommand{\cf}{{\em cf.}}
\newcommand{\tup}[1]{\langle#1\rangle}


\title{Quati: An Automated Tool for Proving Permutation Lemmas}
\author{Vivek Nigam\inst{1} \and Giselle Reis\inst{2} \and Leonardo Lima\inst{1}}

\institute{Universidade Federal da Para\'{i}ba, Brazil
\and Technische Universit\"{a}t Wien, Austria
}

%% NOTE: 7 pages tops

%% TODO: references

\begin{document}
\maketitle

\begin{abstract}
The proof of many foundational results in structural proof theory, such as the
admissibility of the cut rule and the completeness of the focusing discipline,
rely on permutation lemmas. It is often a tedious and error prone task to prove
such lemmas as they involve many cases. This paper describes the tool Quati
which is an automated tool capable of proving a wide range of inference rule
permutations for a wide number of proof systems. Given a proof system
specification in the form of a theory in linear logic with subexponentials,
Quati outputs in \LaTeX\ the permutation transformations for which it was able
to prove correctness and also the 
possible derivations for which it was not able to do so. As illustrated in this
paper, Quati's output is very similar to proof derivation figures one would
normally find in a proof theory book. 
\end{abstract}

\section{Introduction}

Permutation lemmas play an important role in proof theory. Many foundational
results about proof systems rely on the fact that some rules
permute over others. For instance, permutation lemmas are used in the Gentzen-style 
cut-elimination proofs~\cite{gentzen}, the completeness of focusing disciplines~\cite{miller07cslb,miller}, 
and the mid-sequent theorem (or Herbrand's theorem)~\cite{herbrand}.

Proving permutation lemmas is often a tedious and error-prone task as there are normally many 
cases to consider. As an example, consider the case of permuting $\vee_l$ over $\rightarrow_l$ in
the intuitionistic calculus \textbf{LJ}. In order to show whether these two
rules permute, one needs to check \emph{every possible case} in which
$\rightarrow_l$ occurs above $\vee_l$ in a derivation. When using a
multiplicative calculus, there are four possibilities for such derivation, two
allow a permutation of the rules while the other two do not.\footnote{In an
additive calculus there are three possibilities, only one of them allow a
permutation.} Here's one of each:
%% -> l / v l
\vspace{-4mm}

{\scriptsize
\[
\infer[\vee_l]{\Gamma, \Gamma', \Gamma'', A \rightarrow B , P \vee Q \vdash F}{
  \deduce{\Gamma, P \vdash F}{\varphi_1\vspace{0.2cm}}
  &
  \infer[\rightarrow_l]{\Gamma', \Gamma'', A \rightarrow B , Q \vdash F}{
    \deduce{\Gamma' \vdash A}{\varphi_2\vspace{0.2cm}}
    &
    \deduce{\Gamma'', Q, B \vdash F}{\varphi_3\vspace{0.2cm}}
  }
}
\quad\rightsquigarrow\quad
\infer[\rightarrow_l]{\Gamma, \Gamma', \Gamma'', P \vee Q, A \rightarrow B
\vdash F}{
  \deduce{\Gamma' \vdash A}{\varphi_2\vspace{0.2cm}}
  &
  \infer[\vee_l]{\Gamma, \Gamma'', P \vee Q, B \vdash F}{
    \deduce{\Gamma, P \vdash F}{\varphi_1\vspace{0.2cm}}
    &
    \deduce{\Gamma'', B, Q \vdash F}{\varphi_3\vspace{0.2cm}}
  }
}
\]
}
%% -> l / v l
{\scriptsize
\[
\infer[\vee_l]{\Gamma, \Gamma', \Gamma'', A \rightarrow B , P \vee Q \vdash F}{
  \deduce{\Gamma, P \vdash F}{\varphi_1\vspace{0.2cm}}
  &
  \infer[\rightarrow_l]{\Gamma', \Gamma'', A \rightarrow B , Q \vdash F}{
    \deduce{\Gamma', Q \vdash A}{\varphi_2\vspace{0.2cm}}
    &
    \deduce{\Gamma'', B \vdash F}{\varphi_3\vspace{0.2cm}}
  }
}
\quad\rightsquigarrow\quad
?
\]
}%
The combinatorial nature of the proof of permutation lemmas can be observed in this example. There are four cases to consider
only for these pair of rules. For proving the completeness of the focusing discipline, 
one needs to study which permutations are allowed; thus one needs to consider all pairs of rules~\cite{miller07cslb}.
Moreover, the
fact that the cases are rarely documented makes it hard for others to check the
correctness of the transformations. The cut-elimination result for
bi-intuitionistic logic, for example, given by Rauszer \cite{rauszer74studia}
was later found to be incorrect \cite{crolard01tcs} exactly because one of the
permutation lemmas was not true. An automated tool to check for these lemmas
would be therefore of great help. This paper introduces such a tool called Quati.

While here we will restrict ourselves to simply illustrate Quati's funcionalities and implementation design, 
we observe that its underlying theory is described in the papers~\cite{nigam.jlc,nigam13iclp,nigam14ebl}. 
 
In \cite{nigam13iclp}, we showed how to reduce the problem of proving permutation lemmas to solving an Answer-Set
Program~\cite{gelfond}. That is given a proof system, $\Pscr$, satisfying some properties, we reduced the problem 
of checking whether a rule $r_1$ in $\Pscr$ always permutes over $r_2$ in $\Pscr$ to solving an Answer-Set Program.
Each solution of the Answer-Set Program corresponds to one possible permutation case. 

The exact language in which proof systems are specified was not dealt in~\cite{nigam13iclp}, but was subject of 
the paper~\cite{nigam.jlc}. This paper shows that a great number of proof systems for different logics,
\eg, linear, intuitionistic, classical, modal logics, can be specified as theories in Linear Logic with Subexponential~\cite{nigam09ppdp}. Moreover, these specifications are shown to have a strong adequacy (on the level of derivations~\cite{nigam10jar}). Thus, Linear Logic
with Subexponentials seems to be a suitable language for specifying proof systems. 

In the workshop paper~\cite{nigam14ebl}, we showed how to intergrate the material in \cite{nigam13iclp} and \cite{nigam.jlc}.
In particular, we show how to reduce to solving an Answer-Set Program the problem of checking whether a rule permutes over another when given 
a proof system specified as a Linear Logic with Subexponentials. Moreover, we also discuss in \cite{nigam14ebl} how to extract proof derivation 
figures similar to those shown in standard proof theory books~\cite{troelstra} from the 
answers of the generated Answer-Set programs. 

Quati is the result of these series of papers. In the following Sections we illustrate its use 
with examples.

% \section{Example}
% 
% \todo{VN: Select a proof system to use as running example.}

\section{Quati at Work}

As discussed above, the specification of proof systems is a theory in Linear Logic with Subexponentials (SELL)~\cite{nigam09ppdp}. 
A Quati program is therefore such a theory with some more annotations. We explain in detail the syntax of Quati programs 
by using as running example the inference rules of the multiconclusion sequent calculus for intuitionistic logic~\cite{maehara}.

% Quati programs are composed by two files, the first one with the subexponential declarations and SELL theories specifying proof systems, 
% while the second file simply contains the type declarations of the constants used. Quati uses the type \texttt{term} for object logic terms. For example, in the following, we declare two constants, \texttt{imp}, for implication, and \texttt{and}, for conjunction symbol. 
% \begin{verbatim} 
% type imp form -> form -> form.
% type and form -> form -> form.
%   \end{verbatim}

\begin{tabular}{ll}
$Side$ ::= & \texttt{lft} $\mid$ \texttt{rght}  \quad $CtxType$ ::=  \texttt{many} $\mid$ \texttt{single} \quad $SubType$ ::=  \texttt{unb} $\mid$ \texttt{lin} \\[2pt]
$SubSig$ ::= & 
{\texttt{subexp} $\tup{String}$ $\tup{SubType}$ .  $\mid$  \texttt{subexpctx} $\tup{String}$ $\tup{CtxType}$ $\tup{Side}$ .}
\\
& {$\mid $ \texttt{subexprel} $\tup{String}$ \texttt{<} $\tup{String}$ .}\\[2pt]
$Bipoles$ ::= & {\texttt{not} $\tup{Atom}$ \texttt{*} $\tup{Body}$}  \quad $Atoms$ ::=  $\tup{Side}$ $\tup{Term}$\\[2pt]
$Body$ ::= & 
{\texttt{top} $\mid$ \texttt{one} $\mid$ $\tup{Atom}$ $\mid$ $\tup{Body} | \tup{Body}$ $\mid$ $\tup{Body} \& \tup{Body}$ }
\end{tabular}
\todo{add other constructs}

where $Term$ is a term of type \texttt{form}.

\section{Implementation Details}

\section{Conclusions and Future Work}


% While this illustrates only one case, proving the focusing discipline, for
% instance, requires that the permutation of every pair of rules is checked. For a
% system with $n$ rules, this amounts to $2^n$ cases.
% 
% The checking of all cases is a tedious and error prone task. Moreover, the
% fact that the cases are rarely documented makes it hard for others to check the
% correctness of the transformations. The cut-elimination result for
% bi-intuitionistic logic, for example, given by Rauszer \cite{rauszer74studia}
% was later found to be incorrect \cite{crolard01tcs} exactly because one of the
% permutation lemmas was not true. An automated tool to check for these lemmas
% would be therefore of great help.
% 
% In this paper we describe such a tool. Section \ref{sec:checking} explains
% briefly the theoretical background that was implemented. Section \ref{sec:quati}
% describes the actual implementation and explains, with an example, how to use
% it. Section \ref{sec:conclusion} summarizes the results obtained and point the
% directions of future work.

% \section{Checking proof transformations}
% \label{sec:checking}
% 
% % Explain briefly the method and cite other papers.
% % This section should be small or even merged to the introduction.
% 
% Given a sequent calculus proof system, it was shown in \cite{ENTCS?} that it
% is possible to encode it, under certain conditions, in linear logic with
% subexponentials. This is a refinement of linear logic that allows an
% arbitrary (finite) number of different types of the modalities $!$ and $?$. Each
% one corresponds to a different context in the sequent of the object logic. In
% this encoding, each inference rule of the object logic corresponds to a
% formula in subexponential linear logic. This formula is called a \emph{bipole} because of its
% particular nesting of operators, and its derivation, also called a bipole, is composed by exactly one
% negative and one positive phase in the \emph{focusing} discipline. The details
% of the encoding and the format of these derivations is out of the scope of this
% paper and we refer the curious reader to \cite{llinda} and \cite{JLC paper} for
% a deeper explanation. For the moment, it is enough to know that this encoding
% has the highest level of adequacy \cite{adequacy??}, meaning that one inference
% rule in the object logic corresponds exactly to one bipole derivation in
% focused linear logic with subexponentials (SELLF).
% 
% This correspondence allows the use of SELLF as a framework to reason
% uniformly over a range of different proof systems for different logics. In
% \cite{JLC?}, the authors show how to prove the admissibility of cut and atomic
% initial rules\footnote{This method was implemented and released as the tool
% TATU (\url{https://www.logic.at/staff/giselle/tatu/}).}, and in \cite{iclp
% paper} it is shown how to use SELLF and answer-set programming to verify proof
% transformations. Quati implements the ideas on the latter work to check
% automatically whether two inference rules permute. 
% 
% \begin{definition}
% Let $\alpha$ and $\beta$ be two inference rules in a sequent calculus proof
% system. We say that $\alpha$ permutes over $\beta$ if \emph{every} possible
% derivation that has an application of $\beta$ immediately followed by and
% application of $\alpha$ (i.e. $\beta$ is above $\alpha$) can be transformed into
% a derivation where $\alpha$ is followed by $\beta$.
% \end{definition}
% 
% Using the SELLF specification of a rule, generic contexts and answer-set
% programming, we can determine all the instances of an inference rule
% application to a sequent \cite{iclp}. It is worth noting that this reasoning is
% actually done on the linear logic level. So the derivation with generic contexts
% is done in SELLF, and the models of the answer-set program specify bipole
% derivations. But because of the specifications' high level of adequacy, we can
% directly translate the bipole derivations to rules of the specified logic. A
% rewriting system is presented in \cite{iclp} for this translation.
% 
% Given this algorithm, it is possible to specify all instances of $\alpha$ on a
% generic sequent containing main formulas for $\alpha$ and $\beta$. For each of
% these instances, we can also specify how $\beta$ can be applied on its premises.
% Taking all possible combinations, we have the set $\mathcal{S}_1$ of
% derivations in which $\beta$ is immediately above $\alpha$. Repeating the
% procedure with the rules switched, we have the set $\mathcal{S}_2$ of
% derivations in which $\alpha$ is immediately above $\beta$. To check the
% permutation of $\alpha$ over $\beta$, one needs to check if a proof of each
% derivation $d \in \mathcal{S}_1$ implies in a proof of some derivation $d' \in
% \mathcal{S}_2$. The provability implication of derivations can also be
% determined via an answer-set program described in \cite{iclp}.

\section{Quati}
\label{sec:quati}

%% TODO: make a release with only the functionalities for quati to work. Put it
%% in the downloads section of google code so that we can refer to the link here.
%% Remember to put only the examples that are currently working!!
%% Write a readme file!!

Quati is implemented in OCaml\footnote{\url{http://ocaml.org/}} and makes use of
DLV\footnote{\url{http://www.dlvsystem.com/dlv/}} externally to compute minimal models for the
answer-set programs generated. It is part of a bigger project, called
\texttt{sellf}\footnote{\url{https://code.google.com/p/sellf/}} which started as an effort to
implement the focused proof system for linear logic with subexponentials
\cite{vivek's thesis}. The basic data structure is linear logic formulas,
defined in the \texttt{Term} module. Figure \ref{fig:modules} is an overview
of the modules in \texttt{sellf} used by Quati to check for permutations.

\begin{figure}
TODO: module's figure
\end{figure}

\textbf{TODO:} wait for the picture to explain in more detail the modules and how they
interact.

Quati takes as input the SELLF specification of a sequent calculus proof system.
This is done via two files, one with extension \texttt{.pl} and the other with
\texttt{.sig}. The former contains the actual specification of the proof system,
namely, the formulas corresponding to each inference rule, the subexponentials
used and their properties. The latter contains a signature declaration of the
connectives of the object logic. For example, if the logic being specified has a
connective $\wedge$, one needs to declare a predicate, say \texttt{and}, of type
\texttt{form -> form -> form}. Figure \ref{fig:input} shows an example of these
input files and Tables \ref{tbl:syntax_ll} and \ref{tbl:syntax} show the syntax of the
linear logic connectives and some keywords used in specifications.

\begin{figure}
\begin{verbatim}
%%%%%%%%%%%%%%%%%%% Specification %%%%%%%%%%%%%%%%%%%%
subexp l unb.
subexp r unb.
subexpctx l many lft.
subexpctx r many rght.

rules introduction.
% Implication
(not (lft (imp A B))) * (([r]? (rght A)) * ([l]? (lft B))).
(not (rght (imp A B))) * [l]bang ( ([l]? (lft A)) | ([r]? (rght B))).

% Forall
(not (lft (forall A))) * sigma \X ([l]? (lft (A X))).
(not (rght (forall A))) * [l]bang (pi \X ([r]? (rght (A X)))).
\end{verbatim}
\begin{verbatim}
%%%%%%%%%%%%%%%%%%% Signature %%%%%%%%%%%%%%%%%%%%
type imp form -> form -> form.
type forall (term -> form) -> form.
\end{verbatim}
\caption{Specification and signature files of the multi-conclusion
calculus for intuitionistic logic \textbf{mLJ}.}
\label{fig:input}
\end{figure}
%
\begin{table}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
\texttt{*} : $\otimes$ & \texttt{+} : $\oplus$ & \texttt{\&} : $\&$ & \texttt{|} : $\bindnasrepma$ & \texttt{[i]bang} : $!^i$ \\
\hline
\texttt{one} : $1$ & \texttt{zero} : $0$ & \texttt{top} : $\top$ & \texttt{bot} : $\bot$ & \texttt{[i]?} : $?^i$ \\
\hline
\end{tabular}
\vspace{0.2cm}
\caption{Syntax for the linear logic connectives.}
\label{tbl:syntax_ll}
\end{table}
%
\begin{table}
\centering
\begin{tabular}{|c|l|}
\hline
Syntax & Meaning \\
\hline
\hline
%% TODO: maybe these deserve a better explanation...
\texttt{rght A} & $\lceil A \rceil$ (represents a formula $A$ on the right side of the sequent in the object logic)\\
\hline
\texttt{lft A} & $\lfloor A \rfloor$ (represents a formula $A$ on the left side of the sequent in the object logic)\\
\hline
\texttt{form} & Type for object logic formulas.\\
\hline
\texttt{term} & Type for object logic terms.\\
\hline
\texttt{subexp} & Keyword to declare contexts.\\
\hline
\texttt{unb} or \texttt{lin} & Specifies whether a context allows contraction and weakening of its formulas.\\
\hline
\texttt{subexpctx} & Keyword to declare contexts' properties.\\
\hline
\texttt{many} or \texttt{single} & Specifies the number of formulas a context can hold.\\
\hline
\texttt{lft} or \texttt{rght} & Specifies whether a context occurs on the left or on the right side of the sequent.\\
\hline
\end{tabular}
\vspace{0.2cm}
\caption{Syntax reference for specification of systems.}
\label{tbl:syntax}
\end{table}
%
%% put the grammar of the syntax instead???
There are already a few proof systems specified in Quati, such as \textbf{LK},
\textbf{LJ}, \textbf{mLJ}, \textbf{LL}, etc. They were used for testing purposed
and are available for the user as examples. Quati can be downloaded at
\url{[TODO: link of the release]} as a zip containing its source code, the
examples and installation instructions. Alternatively, it can be tested using a
limited web interface at \url{https://www.logic.at/staff/giselle/quati/}.

\subsection{An example session}

We will illustrate the features of Quati using a sample run on the command line
interface. This is preferred over the web interface because it provides extra
functionality.

%% TODO: demo session on the command line
% load file
% type bipoles to print the rules
% show the latex code that's printed for one rule as the object logic rule and
% the linear logic bipole
% type permute to check permutation of two rules
%   one example that permute
%   - show the permutations as object logic rules
%   one example that does not permute
%   - show the successful and failed cases as ol rules

\section{Conclusion}
\label{sec:conclusion}

- mention the systems implemented and interesting cases of permutation

- cite the work with ramyaa about automating the specifications

- cite the automatic discovery of focusing systems

\end{document}
